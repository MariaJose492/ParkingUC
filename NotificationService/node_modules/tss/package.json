{
  "name": "tss",
  "version": "0.0.24",
  "author": {
    "name": "Noferi Mickaël",
    "email": "noferov@gmail.com"
  },
  "description": "a minimal template engine",
  "license": [
    {
      "type": "CC BY-NC-SA 3.0",
      "url": "http://creativecommons.org/licenses/by-nc-sa/3.0/"
    }
  ],
  "repository": {
    "type": "git",
    "url": "https://github.com/r043v/tss.git"
  },
  "main": "tss.js",
  "keywords": [
    "template",
    "async",
    "callback"
  ],
  "dependencies": {
    "async": "git://github.com/caolan/async",
    "async-replace": "git://github.com/kesla/async-replace"
  },
  "engines": {
    "node": "*"
  },
  "readme": "\ttss\n---------------\n\ntss is a minimal templage engine,\nunlike all other template system tss not use any pseudo langage into the template,\n\ninstead, to really separate design from code it is fully callback based\n\nonly one char define template keywords : **§**, nothing else need to be know\n\n**install tss**\n\nnpm install tss\n\n**import tss**\n\n\tvar tss = require(\"tss\").tss;\n\n**how to & example**\n\t\nsyntax is easy :\n\n\tvar filledTemplate = tss(template, data, callback);\n\ncallback use is optionnal, if there is not any, tss will just replace keywords with their associed data or with empty string ''\n\nminimal example, not any use of callback\n\n\ttss(\"hello §name§\",{\n\t\tname : \"world\"\n\t});\n\n\twill return \"hello world\"\n\nif data is an array, tss will loop itself on each value :\n\n\t\"<ul>\" + tss(\"<li>§name§</li>\",[\n\t\t{ name : \"john\" },\n\t\t{ name : \"mike\" },\n\t\t{ name : \"kate\" }\n\t]) + \"</ul>\";\n\t\nwill result in :\n\t\n\t<ul>\n\t\t<li>john</li>\n\t\t<li>mike</li>\n\t\t<li>kate</li>\n\t</ul>\n\ncallback can be an object with some function, or a \"generic\" single function, \"this\" in callback will always refer to the data object\n\ncallback object example :\n\n\ttss(\"§greetings§ §name§\",{\n\t\tname : \"world\",\n\t\tgreetings : \"hello\"\n\t},{\n\t\tname : function(name){\n\t\t\treturn name.toUpperCase();\n\t\t\t// or this.name.toUpperCase();\n\t\t}\n\t});\n\n\twill return \"hello WORLD\"\n\nsingle generic callback function example :\n\n\ttss(\"hello §name§\",{\n\t\tname : \"world\"\n\t},function(keyword){\n\t\tswitch(keyword){\n\t\t\tcase 'name' : return this.name.toUpperCase(); break;\n\t\t}\treturn '';\n\t});\n\nkeywords can be \"virtual\", not any dedicated data, but generated by callback\n\n\ttss(\"hello §name§\",{\n\t\tuserName : \"world\"\n\t},{\n\t\tname : function(){\n\t\t\treturn this.userName.toUpperCase();\n\t\t}\n\t});\n\nthat work with the two syntax :\n\t\n\ttss(\"hello §name§\",{\n\t\tuserName : \"world\"\n\t},function(keyword){\n\t\tswitch(keyword){\n\t\t\tcase 'name' : return this.userName.toUpperCase(); break;\n\t\t}\treturn '';\n\t});\n\nextract all handler and templates into dedicated data object for maximum reuse and abstraction :\n\n\tvar template = {\n\t\tuser : {\n\t\t\tregistered : 'hello user §id§ <b>§name§</b> <a href=\"/logout\">logout</a>',\n\t\t\tunregistered : 'Hello unregistered user, <a href=\"/auth/google\">login</a>',\n\t\t\tuserpage : '<h1>user §id§</h1><section><h2>§name§</h2><p>§email§</p></section>'\n\t\t}\n\t}\n\n\tvar handler = {\n\t\tuser : {\n\t\t\tname:function(){\n\t\t\t\tswitch(this.account){\n\t\t\t\t\tcase 'google':\n\t\t\t\t\t\treturn this.profile.displayName;\n\t\t\t\t\tbreak;\n\t\t\t\t};\treturn 'anon';\n\t\t\t},\n\t\t\tmail:function(){\n\t\t\t\tswitch(this.account){\n\t\t\t\t\tcase 'google':\n\t\t\t\t\t\treturn this.profile.emails[0].value;\n\t\t\t\t\tbreak;\n\t\t\t\t};\treturn 'not any mail';\n\t\t\t}\n\t\t}\n\t};\n\n\tvar html = tss(template.user.userpage,user,{\n\t\tname:handler.user.name,\n\t\temail:handler.user.mail\n\t});\n\t\nor directly :\n\n\tvar html = tss(template.user.userpage,user,handler.user);\n\n\t\n**async**\n\t\ndefault tss use is sync, but it can be used in an async way,\nfor that purpose it will require [async] and [async-replace] npm packages\n\nasync tss can be used simply with :\n\n\ttss.async(template, data, callback, done);\n\nall data callback will get an extra parameter who is the job end callback\n\n\ttss.async(\"hello §name§\",{\n\t\tname : \"world\"\n\t},{\n\t\tname : function(name,done){\n\t\t\tsetTimeout(function(){\n\t\t\t\tdone(null,'<i>'+name+'</i>');\n\t\t\t},1000);\n\t\t}\n\t},function(err,data){\n\t\tconsole.log( \"filled data : \", data);\n\t});\n\nfor virtual keywords :\n\t\n\ttss.async(\"hello §name§\",{\n\t\tmyname : \"world\"\n\t},{\n\t\tname : function(done){\n\t\t\tvar t = this;\n\t\t\tsetTimeout(function(){\n\t\t\t\tdone(null,'<i>'+t.myname+'</i>');\n\t\t\t},1000);\n\t\t}\n\t},function(err,data){\n\t\tconsole.log( \"filled data : \", data);\n\t});\n\nthe use of this job end callback is *optionnal*,\nif your data callback return anything the job callback will not be used,\nyou can mix async && sync data callback :\n\n\ttss.async(\"hello <i>§name§</i>, glad to see you back §time§\",{\n\t\t login : \"kate\",\n\t\tgender : \"Miss\"\n\t},{\n\t\tname : function(){\n\t\t\treturn this.gender + \" \" + this.login;\n\t\t},\n\t\ttime : function(done){\n\t\t\tdb.get(\"users:last-ping:\"+this.login,function(err,time){\n\t\t\t\ttime = (new Date()) - time; // from now\n\t\t\t\ttime /= 1000*3600*24; // in day\n\t\t\t\tif(time > 90) return done(null, \"from death\");\n\t\t\t\tvar timeString = (time > 7)?\"after so long time !\":\"so fast.\";\n\t\t\t\tdone(null, timeString );\n\t\t\t});\n\t\t}\n\t},function(err,data){\n\t\tres.send( data );\n\t});\n\nand if there is not any callback for a keyword, this one will just be done in a sync way :\n\n\tfunction toUpperCase(s){ return s.toUpperCase(); }\n\tvar smiles = { cool:\":)\", great:\":D\" };\n\n\ttss.async(\"§greetings§ §name§ this is a §what§ ! §smile§\",{\n\t\t  myname : \"world\",\n\t\t    what : \"test\",\n\t\tgreetings : \"hello\",\n\t\t  feeling : \"great\"\n\t},{\n\t\tname:function(done){\n\t\t\tvar t = this;\n\t\t\tsetTimeout(function(){\n\t\t\t\tdone(null,'<i>'+t.myname+'</i>');\n\t\t\t},1000);\n\t\t},\n\t\tsmile:function(){\n\t\t\treturn smiles[this.feeling];\n\t\t},\n\t\tgreetings:toUpperCase\n\t},function(err,data){\n\t\tconsole.log(data);\n\t});\n\nthat will log after a second :\n\n\tHELLO <i>world</i> this is a test ! :D\n\nfinally, array data could be async too, and will be processed in parallel\n\t\n\ttss.async(\"§a§\",[\n\t\t{ a:1 },\n\t\t{ a:2 },\n\t\t{ a:3 }\n\t],function(keyword,done){\n\t\tvar t = this;\n\t\tvar time = t.a * 1000;\n\t\tsetTimeout(function(){\n\t\t\tdone(null,\"\\n#\"+t.a+\" took \"+time+\"ms to complete\");\n\t\t},time);\n\t},function(err,data){\n\t\tconsole.log(data);\n\t});\n\nwho will log 3 second after :\n\t\n\t#1 took 1000ms to complete\n\t#2 took 2000ms to complete\n\t#3 took 3000ms to complete\n\nand with a keyword more :\n\t\n\ttss.async(\"§a§ §hello§\",[\n\t\t{ a:1 },\n\t\t{ a:2 },\n\t\t{ a:3 }\n\t],function(keyword,done){\n\t\tvar t = this;\n\t\tvar time = t.a * 1000;\n\t\tsetTimeout(function(){\n\t\t\tdone(null,\"\\n #\"+t.a+\" (\"+keyword+\") took \"+time+\"ms to complete\");\n\t\t},time);\n\t},function(err,data){\n\t\tconsole.log(data);\n\t});\n\nstill output 3 second after :\n\n\t#1 (a) took 1000ms to complete \n\t#1 (hello) took 1000ms to complete\n\t#2 (a) took 2000ms to complete \n\t#2 (hello) took 2000ms to complete\n\t#3 (a) took 3000ms to complete \n\t#3 (hello) took 3000ms to complete\n\t\n  [async]: https://github.com/caolan/async\n  [async-replace]: https://github.com/kesla/async-replace\n",
  "readmeFilename": "readme.md",
  "bugs": {
    "url": "https://github.com/r043v/tss/issues"
  },
  "homepage": "https://github.com/r043v/tss",
  "_id": "tss@0.0.24",
  "_from": "tss@*"
}
